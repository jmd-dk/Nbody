# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015–2020 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see https://www.gnu.org/licenses/
#
# The author of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.
# This makefile accepts the options
#   native_optimizations
#   no_optimizations
#   unsafe_building
# all of which may be either 'True' or 'False',
# with unset values being equivalent to 'False'.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles =         \
    analysis      \
    commons       \
    communication \
    ewald         \
    fluid         \
    graphics      \
    gravity       \
    integration   \
    interactions  \
    linear        \
    main          \
    mesh          \
    snapshot      \
    species       \
    utilities     \

# Filename of the module holding common definitions
commons = commons.py
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# Filename of the temporary .pyx file storing the custom types
types = .types.pyx
# List of files and directories generated in the concept directory by
# building and running the code, which should be removed by the
# distclean target (the types file is removed by the clean target).
files_auxiliary =      \
    ../install_log     \
    ../install_log_err \
    .exit_code_*       \
    .lto_test.*        \
    jobscript          \

# List of files and directories in the utilities directory
# generated by using the utilities.
files_utilities = \
    params        \
    update_new    \



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths_filename = $(shell this_dir="$(CURDIR)"; \
    path="$${this_dir}";                       \
    while :; do                                \
        if [ -f "$${path}/.paths" ]; then      \
            paths_filename="$${path}/.paths";  \
            break;                             \
        fi;                                    \
        if [ "$${path}" == "/" ]; then         \
            paths_filename='fail';             \
            break;                             \
        fi;                                    \
        path="$$(dirname "$${path}")";         \
    done;                                      \
    echo "$${paths_filename}";                 \
)
ifeq ($(paths_filename),fail)
    $(error Could not find the .paths file)
endif
# Include (absolute) paths from the .paths file
include $(paths_filename)
# Function which takes in a quoted or unquoted argument. If this
# argument is a path (perhaps prefixed with e.g. -I) and it is located
# near this Makefile, the return value is the relative path. Otherwise,
# the return value is just the untouched argument.
# A backslash will be placed before spaces.
sensible_paths = $(shell $(python) -B -c "pass;                                       \
    import os, sys;                                                                   \
    paths = [path.strip(' \"').strip(\"'\") for path in ''' $1 '''.split()];          \
    paths = [path for path in paths if path];                                         \
    not paths and sys.exit();                                                         \
    prefixes = [([''] + [prefix for prefix in ('-I', '-L', '-Wl,-rpath=')             \
        if path.startswith(prefix)])[-1] for path in paths];                          \
    abspaths = [path[len(prefix):] for path, prefix in zip(paths, prefixes)];         \
    relpaths = [os.path.relpath(abspath, '.') for abspath in abspaths];               \
    paths = [(prefix + (abspath if relpath.startswith('../..') else relpath)).strip() \
        for prefix, abspath, relpath in zip(prefixes, abspaths, relpaths)];           \
    print(' '.join(paths));                                                           \
")

# Read in the paths
paths = $(shell grep -o '.*=' $(paths_filename) | sed 's/.$$//')
# Check whether the Python interpreter works.
# Error out if not.
python_test = $(shell $(python) -B -c "print('success')")
ifneq ($(python_test),success)
    $(error Try sourcing the concept script)
endif
# Transform all the included paths to sensible paths
# to reduce screen clutter when making.
$(foreach path,$(paths),$(eval $(path)=$(call sensible_paths,$($(path)))))



########################################
# Settings for compilation and linking #
########################################
# Function which eliminates duplicates
define unique
$(shell $(python) -B -c "pass;
    import re;
    unique_word_patterns = {r'^-D', r'^-I', r'^-L', r'^-O', r'^-W', r'^-l'};
    words = [word for word in '$1'.split() if word];
    words_prev = set();
    words = [(word, words_prev.add(word))[0] for word in words if not word in words_prev
        or not any(re.search(pattern, word) for pattern in unique_word_patterns)
    ];
    print(' '.join(words));
")
endef

# The python configuration script
python_config = $(shell readlink -f $$(which $(python)))-config
# Options passed when cythonizing .pyx files
python_version_major = $(shell $(python) -B -c "import sys; print(sys.version_info.major)")
cythonflags = -$(python_version_major) -D -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_includedir)
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC = $(mpicc)
compiler = $(shell                                           \
    info="$$($(CC) --version 2>/dev/null | head -n 1 || :)"; \
    if echo "$${info}" | grep -i icc >/dev/null; then        \
        echo "icc";                                          \
    elif echo "$${info}" | grep -i intel >/dev/null; then    \
        echo "icc";                                          \
    elif echo "$${info}" | grep -i gcc >/dev/null; then      \
        echo "gcc";                                          \
    else                                                     \
        echo "gcc";                                          \
    fi                                                       \
)
unwanted_warnings =            \
    implicit-fallthrough       \
    misleading-indentation     \
    missing-field-initializers \
    strict-overflow            \
    uninitialized              \
    unknown-warning-option     \

python_cflags = $(filter-out             \
    $(addprefix -W,$(unwanted_warnings)) \
    -g -g0 -g1 -g2 -g3                   \
    -O -O0 -O1 -O2 -O3 -Og -Os -Ofast    \
    -fwrapv                              \
    ,                                    \
    $(shell $(python_config) --cflags)   \
)
other_cflags =                              \
    -std=c99                                \
    -pthread                                \
    -fPIC                                   \
    -Wall                                   \
    -Wextra                                 \
    $(addprefix -Wno-,$(unwanted_warnings)) \

# Options specific to the compiler implementation
ifeq ($(compiler),icc)
    # Filter out warnings
    other_cflags += -wd111    # Unreachable statement
    other_cflags += -wd10006  # Ignoring unknown option
    other_cflags += -wd10148  # Option not supported
    other_cflags += -wd11074  # Inlining inhibited
    other_cflags += -wd11076  # How to get full report
endif
# Optimization options
ifneq ($(no_optimizations),True)
    # General optimizations
    optimizations        += -DNDEBUG -O3 -funroll-loops
    optimizations_linker += -O3
    # Floating point optimizations
    ifeq ($(compiler),gcc)
        optimizations += -ffast-math
    else ifeq ($(compiler),icc)
        optimizations += -fp-model fast=2
    endif
    # Better inlining
    ifeq ($(compiler),gcc)
        optimizations += --param max-inline-insns-auto=100 --param early-inlining-insns=200
    else ifeq ($(compiler),icc)
        optimizations += -inline-factor=200
    endif
    # Native optimizations
    ifeq ($(native_optimizations),True)
        optimizations += -march=native
    endif
    # Link time optimizations
    lto_warning = $(shell                                           \
        echo "int main(void){ return 0; }" > .lto_test.c;           \
        $(CC) -flto -c -o .lto_test.o .lto_test.c 2>&1 | grep flto; \
        $(RM) -f .lto_test.c .lto_test.o                            \
    )
    ifeq ("$(lto_warning)","")
        optimizations        += -flto
        optimizations_linker += -flto
    endif
endif
CFLAGS += $(call unique, $(call sensible_paths, \
    $(python_cflags)                            \
    $(other_cflags)                             \
    $(optimizations)                            \
    $(includes)                                 \
))

# Libraries to link
fftw_libs = -L$(fftw_dir)/lib -Wl,-rpath=$(fftw_dir)/lib -lfftw3_mpi -lfftw3
ifneq ("$(wildcard $(blas_dir)/lib/libopenblas.*)","")
    # OpenBLAS found
    gsl_blas_libs = -L$(blas_dir)/lib -Wl,-rpath=$(blas_dir)/lib -lopenblas
else ifneq ("$(wildcard $(blas_dir)/lib/libblas.*)","")
    # Some BLAS found
    gsl_blas_libs = -L$(blas_dir)/lib -Wl,-rpath=$(blas_dir)/lib -lblas
else
    # No BLAS found
    gsl_blas_libs = -lgslcblas
endif
gsl_libs = -L$(gsl_dir)/lib -Wl,-rpath=$(gsl_dir)/lib -lgsl $(gsl_blas_libs) -lm
mpi_libs = -L$(mpi_libdir) -Wl,-rpath=$(mpi_libdir) -lmpi
ifneq ("$(wildcard $(mpi_symlinkdir))","")
    mpi_libs += -L$(mpi_symlinkdir) -Wl,-rpath=$(mpi_symlinkdir)
endif
python_libdir = $(shell $(python) -B -c "pass; \
    import sysconfig;                          \
    print(sysconfig.get_config_var('LIBDIR')); \
")
python_libs = -L$(python_libdir) -Wl,-rpath=$(python_libdir) $(shell $(python_config) --libs)
LDLIBS += $(call unique, $(call sensible_paths, \
    $(fftw_libs)                                \
    $(gsl_libs)                                 \
    $(mpi_libs)                                 \
    $(python_libs)                              \
))

# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
comma = ,
LDFLAGS += $(call unique, $(call sensible_paths,      \
    $(python_ldflags)                                 \
    $(other_ldflags)                                  \
    $(optimizations)                                  \
    $(addprefix -Wl$(comma),$(optimizations_linker))  \
))



###################
# Primary targets #
###################
# The below recipes are responsible for the
# .py --> ((.pyx --> types) --> .pxd) --> (.c + .html) --> .o --> .so
# build chain. A heading is printed at the beginning of the build.
building = modules
define heading
    $(python) -B -c "pass;                                                              \
        import sys;                                                                     \
        from time import sleep;                                                         \
        import blessings;                                                               \
        sys.exit() if '$(heading_printed)' else None;                                   \
        extra = [];                                                                     \
        extra.append('native optimizations')                                            \
            if '$(native_optimizations)' == 'True' and '$(no_optimizations)' == 'False' \
            else None;                                                                  \
        extra.append('no optimizations')                                                \
            if '$(no_optimizations)' == 'True'                                          \
            else None;                                                                  \
        extra.append('unsafe')                                                          \
            if '$(unsafe_building)' == 'True'                                           \
            else None;                                                                  \
        extra = (' (' + ', '.join(extra) + ')')                                         \
            if extra                                                                    \
            else '';                                                                    \
        terminal = blessings.Terminal(force_styling=True);                              \
        print(terminal.bold_yellow('Building $(building)' + extra), flush=True);        \
    "
    $(eval heading_printed = True)
    sleep 0.1
endef

# Make all compiled Python modules.
# When finished, update time stamps so that all dependencies are
# synchronized (this is needed because .pxd files are only updated
# when their contents actually change. That is, `make pyfile.pxd` does
# not necessarily update the timestamp of pyfile.pxd, even though its
# rule is run. This makes .c (and therefore .o and .so) files
# dependent on such .pxd files not up-to-date). The types file is also
# only updated when its content actually changes.
all: $(addsuffix .so, $(pyfiles))
ifeq ($(MAKELEVEL),0)
	@$(MAKE) -s -t $@
endif
.PHONY: all

# Link object files into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(call heading)
	$(CC) $< -o $@ $(call unique, $(LDFLAGS) $(LDLIBS))

# Compile C source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(call heading)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into C source files
# (and also produce the annotated .html file).
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(call heading)
	$(python) -m cython $(cythonflags) $<
# Same as above (for explicit builds of html)
$(addsuffix .html, $(pyfiles)): %.html: %.pyx %.pxd
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files together with the types file
# using the pyxpp script.
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(types)
	@$(call heading)
	$(python) -B $(pyxpp) $< $(commons) $(types)

# Write the types file from the .pyx files using the pyxpp script
$(types):
	@$(call heading)
	$(python) -B $(pyxpp) $@ $(commons) $(types) $(addsuffix .pyx, $(pyfiles))

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py
	@$(call heading)
ifneq ($(no_optimizations),True)
	$(python) -B $(pyxpp) $< $(commons)
else
	$(python) -B $(pyxpp) $< $(commons) --no-optimizations
endif



##################
# Other  targets #
##################
# For building the documentation
docs:
	@$(MAKE) -C $(docs_dir) --no-print-directory
.PHONY: docs
# For printing Makefile variables
print_vars:
	$(foreach var, $(.VARIABLES), $(info $(var) = $($(var))))
.PHONY: print_vars



###########################
# Additional dependencies #
###########################
# Additional target dependencies
$(foreach ext,c html,$(addsuffix .$(ext), mesh)): fft.c
# Target dependencies which strictly speaking should be
# taken into account, but can be ignored using the --unsafe-building flag.
ifneq ($(unsafe_building),True)
    # Use of inline iterators defined in other modules
    # makes the .pyx files depend on the .py file
    # of the module implementing the iterator.
    gravity.pyx:      interactions.py  # particle_particle()
    analysis.pyx:     mesh.py          # slab_fourier_loop()
    interactions.pyx: mesh.py          # slab_fourier_loop()
    linear.pyx:       mesh.py          # slab_fourier_loop()
    # Because modules cimport stuff from each other, some .c
    # (and therefore also .html) files depend on the .pxd files of
    # other modules.
    $(foreach ext,c html,$(addsuffix .$(ext), $(pyfiles))): $(addsuffix .pxd, $(pyfiles))
    # Every module cimport everything from the commons module.
    # The commons module is also needed when building the types file.
    $(foreach ext,pyx pxd,$(addsuffix .$(ext), $(pyfiles))): $(commons)
    $(types): $(commons)
    # The pyxpp script is used to create .pyx files,
    # .pxd files, .c files and the types file.
    $(foreach ext,pyx pxd c,$(addsuffix .$(ext), $(pyfiles))): $(pyxpp)
    $(types): $(pyxpp)
    # The types file potentially depend on all .pyx files
    $(types): $(addsuffix .pyx, $(pyfiles))
    # Let the bottom of the build chain depend on this makefile itself
    $(addsuffix .pyx, $(pyfiles)): $(MAKEFILE_LIST)
endif



###################
# Cleanup targets #
###################
.PHONY:                   \
    clean                 \
    clean_autosave        \
    clean_auxiliary       \
    clean_docs            \
    clean_ics             \
    clean_logs            \
    clean_output          \
    clean_params_cp       \
    clean_reusables       \
    clean_class_reusables \
    clean_ewald_reusables \
    clean_fftw_reusables  \
    clean_tests           \
    clean_utilities       \
    distclean             \

# Remove all compile files
clean:
	$(RM) -r $(foreach ext,pyc pyx pxd c html o so so_,\
	    $(addsuffix .$(ext), $(pyfiles))) $(types) __pycache__
# Remove files generated via autosave
clean_autosave:
	$(RM) $(ics_dir)/autosave_*
	$(RM) $(params_dir)/autosave_*
# Remove auxiliary files generated by running the program
clean_auxiliary:
	$(RM) -r $(files_auxiliary)
# Remove everything in the ICs directory
clean_ics:
	$(RM) -r $(ics_dir)/* $(ics_dir)/.[^.]*
# Remove documentation build
clean_docs:
	@$(MAKE) -C $(docs_dir) clean_sphinx --no-print-directory
# Remove everything in the log directory
clean_logs:
	$(RM) -r $(logs_dir)/* $(logs_dir)/.[^.]*
# Remove everything in the output directory
clean_output:
	$(RM) -r $(output_dir)/* $(output_dir)/.[^.]*
# Remove parameter file copies
clean_params_cp:
	$(RM) $(params_dir)/.[0-9]*
# Remove reusable dumps
clean_reusables:
	$(RM) -r $(reusables_dir)
clean_class_reusables:
	$(RM) -r $(reusables_dir)/class
clean_ewald_reusables:
	-$(RM) -r $(reusables_dir)/ewald
clean_fftw_reusables:
	$(RM) -r $(reusables_dir)/fftw
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) -r $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/tmp
# Remove all unnecessary files,
# leaving CO𝘕CEPT in a distribution ready state.
# Note that no files in the ics or output directory will be removed,
# and that only auto-generated files will be removed from the
# params directories.
distclean:          \
    clean           \
    clean_autosave  \
    clean_auxiliary \
    clean_docs      \
    clean_logs      \
    clean_params_cp \
    clean_reusables \
    clean_tests     \
    clean_utilities \

